{
    "title": "Resumo sobre \"Never* Use Arrays\"",
    "subtitle": "Conteúdo original de Larry Garfield (Typo3 / PHPFIG Core Committee / RFCs Editor)",
    "author": "Rui H L Oliveira",
    "date": "26 de Junho 2021",
    "body": [
        "Você pode reconhecer um programador php por ele usa array demais. No PHP o array é uma estrutura muito versátil. A ausência histórica de tipagem para variáveis e a definição do array php como estrutura de dados heterogêneos (que podem ser de mais de uma natureza, mais de um tipo) provoca seu uso indiscriminado em diversas situações.",
        "Existe aí um problema envolvendo a garantia da existência de um dado tipo em uma dada posição de um array. Já em outras linguagens fortemente tipadas, existe a necessidade do array/vetor possuir um tipo definido, ou seja, ser uma coleção homogênea, e o questionamento “a posição x do array tem um objeto do tipo Y, do tipo Z, ou um tipo primitivo de dado?” não ocorre.",
        "Porém, esse não é o único problema.",
        "Para começar, é necessário explicar que, ao usar arrays php, você na realidade usa sempre arrays associativos, nunca arrays definidos por offset.",
        "Array associativo nós já conhecemos. Em outras linguagens, pode ser chamado de dicionário ou Map, uma estrutura chave-valor onde a chave é definida manualmente. Porém, o que é um offset? Um offset é o mesmo que um valor de deslocamento a partir de um ponto. Uma distância a partir do ponto 0, no nosso caso. Um offset 1 é uma posição a partir do 0. O offset 2 são duas posições a partir do 0.",
        "Isso não existe no array php. Mesmo arrays numerados são arrays associativos. De acordo com Garfield, arrays com índice numerado, em php, são feitos através de uma espécie de gambiarra: o incremento do último índice numerado. Um comportamento curioso demonstrável é que, ao tentar criar uma posição em um array usando um float como chave, o valor é arredondado para baixo.",
        "Exemplo 1: Arrays - Indice float arredondado para baixo",
        "<code>$array = [\n    'primeiro',\n    'segundo',\n    'terceiro'\n];\n\nvar_dump($array);\n/*\narray(3) {\n  [0]=>\n  string(8) \"primeiro\"\n  [1]=>\n  string(7) \"segundo\"\n  [2]=>\n  string(8) \"terceiro\"\n}\n*/\n$array[3.5] = \"quarto\";\n$array[4.8] = \"sala\";\n\nvar_dump($array);\n/*\narray(5) {\n  [0]=>\n  string(8) \"primeiro\"\n  [1]=>\n  string(7) \"segundo\"\n  [2]=>\n  string(8) \"terceiro\"\n  [3]=>\n  string(6) \"quarto\"\n  [4]=>\n  string(4) \"sala\"\n}\n*/</code>",
        "Um problema gerado por isso é, ao usar um laço FOR em um array de índice numerado, corremos o risco de tentar acessar um índice não existente, pois, ao realizar unset em uma posição do array, os outros elementos não têm seus índices reorganizados.",
        "Exemplo 2: Arrays - Removendo posição entre duas posições e rodando for",
        "<code>$array = [\n    'primeiro',\n    'segundo',\n    'terceiro'\n];\nunset($array[1]);\nvar_dump($array);\n/*\narray(2) {\n  [0]=>\n  string(8) \"primeiro\"\n  [2]=>\n  string(8) \"terceiro\"\n}\n*/\n\nfor ($i = 0; $i < count($array); $i++ ){\n    echo \"$i => $array[$i]\";\n}\n/*\n0 => primeiro\nNotice: Undefined offset: 1 in \nC:\\Users\\ruigx\\Desktop\\REPOS\\testesLocais\\teste.php on line 34\n1 => \n*/</code>",
        "Já o operador [ ] para arrays de índice numérico não quer dizer adicionar uma posição de forma ordenada e consistente. O mesmo simplesmente usa um contador interno da estrutura para determinar o próximo índice numero do array. Isso pode ser perigoso, causando o mesmo problema anterior, já que nem a inserção nem a remoção de itens do array reorganiza os índices da estrutura.",
        "Exemplo 3: Arrays - Removendo ultima posição e adicionando mais um;",
        "<code>$array = [\n    'zero',\n    'um',\n    'dois'\n];\n\nvar_dump($array);\n/*\narray(3) {\n  [0]=>\n  string(4) \"zero\"\n  [1]=>\n  string(2) \"um\"\n  [2]=>\n  string(4) \"dois\"\n}\n*/\n\nunset($array[2]);\n$array[] = \"dois\";\n$array[] = \"tres\";\n\nvar_dump($array);\n/*\narray(4) {\n  [0]=>\n  string(4) \"zero\"\n  [1]=>\n  string(2) \"um\"\n  [3]=>\n  string(4) \"dois\"\n  [4]=>\n  string(4) \"tres\"\n}\n*/\n\nunset($array[1]);\n$array[] = \"tres\";\n$array[] = \"quatro\";\nvar_dump($array);\n/*\narray(5) {\n  [0]=>\n  string(4) \"zero\"\n  [3]=>\n  string(4) \"dois\"\n  [4]=>\n  string(4) \"tres\"\n  [5]=>\n  string(4) \"tres\"\n  [6]=>\n  string(6) \"quatro\"\n}\n*/\n</code>",
        "Usamos todos os dias arrays no lugar de estruturas de dados que poderíamos criar para tais propósitos. Isso quase nunca é o que você quer em orientação a objetos. Tenha as estruturas de dados corretas.",
        "O PHP possui estruturas padrão na SPL Standard PHP Library, como ArrayIterator, ArrayObject, entre outras.",
        "Exemplo 4: Spl - Iterando sobre array com ArrayIterator",
        "<code>$array = [\n    'um' => 'primeiro',\n    'dois' => 'segundo',\n    'tres' => 'terceiro'\n];\n$iterator = new ArrayIterator($array);\nwhile ($iterator->valid()) {\n    $indice = $iterator->key();\n    $valor = $iterator->current();\n    echo \"indice: $indice<br>\";\n    echo \"$valor: $valor<br><br>\";\n    $iterator->next();\n}\n$iterator->rewind();\n\n/*\nindice: um\nprimeiro: primeiro\n\nindice: dois\nsegundo: segundo\n\nindice: tres\nterceiro: terceiro\n*/\n</code>",
        "Exemplo 5: Spl - adicionando elemento no array via ArrayIterator definindo chave",
        "<code>$iterator['cinco'] = 'quinto';\nwhile ($iterator->valid()) {\n    $indice = $iterator->key();\n    $valor = $iterator->current();\n    echo \"indice: $indice<br>\";\n    echo \"valor: $valor<br><br>\";\n    $iterator->next();\n}\n$iterator->rewind();\n/*\nindice: um\nvalor: primeiro\n\nindice: dois\nvalor: segundo\n\nindice: tres\nvalor: terceiro\n\nindice: 0\nvalor: quarto\n\nindice: cinco\nvalor: quinto\n\n*/\n</code>",
        "Exemplo 6: Spl - testando itens adicionados no array via iterator, olhando o array original",
        "<code>foreach ($array as $key => $value) {\n    echo \"indice: $key<br>\";\n    echo \"valor: $value<br><br>\";\n}\n/*\nindice: um\nvalor: primeiro\n\nindice: dois\nvalor: segundo\n\nindice: tres\nvalor: terceiro\n*/\n</code>",
        "Exemplo 7: Spl - Iterando sobre arrayObject com ArrayIterator",
        "<code>$array = array(\n    'stack' => 'Overflow',\n    'linguagem' => 'Português',\n    'tags' => 'PHP'\n);\n$arrayobject = new ArrayObject($array);\n$iterator = $arrayobject->getIterator();\nwhile($iterator->valid()) {\n    echo $iterator->key() . ' => ' . $iterator->current() . \"<br>\";\n    $iterator->next();\n}\n$iterator->rewind();\n/*\nstack => Overflow\nlinguagem => Português\ntags => PHP\n*/</code>",
        "Exemplo 8: Spl - Iterando sobre arrayObject somente com foreach",
        "<code>foreach ($arrayobject as $key => $item){\n    echo \"$key => $item<br>\";\n}\n/*\nstack => Overflow\nlinguagem => Português\ntags => PHP\n*/</code>",
        "Exemplo 9: Spl - Iterando sobre um arrayObject sem arrayIterator,\nporém checando se o array iterator é usado",
        "<code>class ArrayObjectSobrescrito extends ArrayObject {\n    public bool $usouGetIterator = false;\n    public function getIterator()\n    {\n        $this->usouGetIterator = true;\n        return parent::getIterator();\n    }\n}\n\n$arrayObjectSobrescrito = new ArrayObjectSobrescrito($array);\nforeach ($arrayObjectSobrescrito as $key => $item){\n    echo \"$key => $item<br>\";\n}\n/*\nstack => Overflow\nlinguagem => Português\ntags => PHP\n*/\n\necho \"usou get iterator?\";\necho $arrayObjectSobrescrito->usouGetIterator;\n/*\nusou get iterator?1 // é o mesmo que true\n*/</code>",
        "Já o autor Larry Garfield dá vários exemplos práticos de estruturas que podem ser usadas no lugar de arrays.",

        "Exemplo 10: Objects - Implementação do TypedArray",
        "<code>class TypedArray extends \\ArrayObject {\n    protected function __construct(...$args) {\n        parent::__construct(...$args);\n    }\n\n    public static function forType(string $type) : object {\n        $array = new static();\n        $array->type = $type;\n        return $array;\n    }\n\n    public function offsetSet($key, $value) {\n        if(! $value instanceof $this->type) {\n            throw new \\TypeError(\n                sprintf('Only values of type %s are supported', $this->type)\n            );\n        }\n        parent::offsetSet($key,$value);\n    }\n}\n\n$typedArray = TypedArray::forType(Produto::class);\n$typedArray[] = Produto::novoProduto()->comNomePreco('Microfone', 400);\n$typedArray[] = Produto::novoProduto()->comNomePreco('Pedestal', 75);\n\nforeach ($typedArray as $key => $value) {\n    echo \"$key => <br>\";\n    var_dump($value);\n}\n/*\n0 =>\n\nobject(Produto)#1 (2) {\n  [\"nome\"]=>\n  string(9) \"Microfone\"\n  [\"preco\"]=>\n  float(400)\n}\n\n1 =>\n\nobject(Produto)#6 (2) {\n  [\"nome\"]=>\n  string(8) \"Pedestal\"\n  [\"preco\"]=>\n  float(75)\n}\n\n*/\n\n$typedArray[] = ['nome'=>'Cordas de violão', 'valor'=>30];\n/*\ndispara :\n Fatal error: Uncaught TypeError: Only values of type Produto are supported in\n C:\\Users\\ruigx\\Desktop\\REPOS\\ruihloliveira.github.io\\teste.php:241 Stack trace:\n #0 C:\\Users\\ruigx\\Desktop\\REPOS\\ruihloliveira.github.io\\teste.php(259): TypedArray->offsetSet()\n #1 {main} thrown in C:\\Users\\ruigx\\Desktop\\REPOS\\ruihloliveira.github.io\\teste.php on line 241\n*/</code>",

        "Exemplo 11: Objects - Fazendo sorting de sortableTypedList de integer",
        "<code>class SortableTypedList extends ArrayObject {\n    protected $type;\n    protected $sortFunction;\n\n    protected function __construct(...$args){\n        parent::__construct(...$args);\n    }\n    public static function withType($type, $sortFunction = null) {\n        $sortableTypedList = new static();\n        $sortableTypedList->type = $type;\n        $sortableTypedList->sortFunction = $sortFunction;\n        return $sortableTypedList;\n    }\n\n    public function getIterator(){\n        return parent::getIterator();\n    }\n\n    public function offsetSet($key, $value) {\n        if(is_object($value) && (! $value instanceof $this->type)){\n            throw new TypeError(\"tipo errado.\");\n        }\n        if(is_scalar($value) && gettype($value) !== $this->type) {\n            throw new TypeError(\"tipo errado.\");\n        }\n        if(is_array($value)){\n            throw new TypeError(\"tipo errado.\");\n        }\n        parent::offsetSet($key, $value);\n    }\n}\n\n$integerList = SortableTypedList::withType(gettype(1));\n$integerList[] = rand(0,100);\n$integerList[] = rand(0,100);\n$integerList[] = rand(0,100);\n\nforeach ($integerList as $key => $item){\n    echo \"$key => $item<br>\";\n}\n/*\n0 => 38\n1 => 25\n2 => 98\n*/\n$integerList->asort();\n\nforeach ($integerList as $key => $item){\n    echo \"$key => $item<br>\";\n}\n/*\n1 => 25\n0 => 38\n2 => 98\n*/</code>",

        "Exemplo 12: Objects - Fazendo sorting de sortableTypedList de Produto",
        "<code>class Produto {\n    public string $nome;\n    public float $preco;\n    public static function novoProduto() {\n        $produto = new static();\n        return $produto;\n    }\n    public static function novoProdutoComNome(string $nome)\n    {\n        $produto = new static();\n        $produto->nome = $nome;\n        return $produto;\n    }\n    public function comNomePreco(string $nome, float $preco) {\n        $this->nome = $nome;\n        $this->preco = $preco;\n        return $this;\n    }\n}\n\n$produtoList = SortableTypedList::withType(Produto::class);\n$produtoList[] = Produto::novoProdutoComNome('pendrive');\n$produtoList[] = Produto::novoProdutoComNome('microfone');\n$produtoList[] = Produto::novoProdutoComNome('1');\n\nforeach ($produtoList as $key => $value) {\n    echo $key . \"=>\" . gettype($value->nome) . \" \" . $value->nome . \"<br>\";\n}\n/*\n0=>string pendrive\n1=>string microfone\n2=>string 1\n*/\n\n\n$produtoList->asort();\n\nforeach ($produtoList as $key => $value) {\n    echo $key . \"=>\" . gettype($value->nome) . \" \" . $value->nome . \"<br>\";\n}\n/*\n\n2=>string 1\n1=>string microfone\n0=>string pendrive\n*/\n\n//provoca erro de tipo quando strict types é true\n$produtoList[] = Produto::novoProdutoComNome(1);</code>",

        "Exemplo 13: Objects - Implementação de sequencia tipada com iterator aggregate e countable",
        "<code>class TypedSequence implements \\IteratorAggregate, \\Countable {\n    protected string $type;\n    protected array $values = [];\n\n    public static function forType(string $type) : iterable {\n        $array = new static();\n        $array->type = $type;\n        return $array;\n    }\n    protected function __construct(){}\n\n    public function count() : int {\n        return count($this->values);\n    }\n\n    public function getIterator() : ArrayIterator {\n        return new ArrayIterator($this->values);\n    }\n\n    public function add ($newValue) : iterable {\n        if (! $newValue instanceof $this->type) {\n            throw new \\TypeError(\n                sprintf('Only values of type %s are supported', $this->type)\n            );\n        }\n        $this->values[] = $newValue;\n        return $this;\n    }\n\n    public function remove ($value): iterable {\n        if($key = array_search($value, $this->values,true)) {\n            unset($this->values[$key]);\n            $this->values = array_values($this->values);\n            return $this;\n        }\n        return $this;\n    }\n}\n\n$typedSequence = TypedSequence::forType(Produto::class);\n$typedSequence->add(Produto::novoProduto()->comNomePreco('Microfone', 400));\n$typedSequence->add(Produto::novoProduto()->comNomePreco('Pedestal', 75));\n\nforeach ($typedSequence as $key => $value) {\n    echo \"$key => <br>\";\n        var_dump($value);\n    }\n/*\n0 =>\n\nobject(Produto)#13 (2) {\n  [\"nome\"]=>\n  string(9) \"Microfone\"\n  [\"preco\"]=>\n  float(400)\n}\n\n1 =>\n\nobject(Produto)#14 (2) {\n  [\"nome\"]=>\n  string(8) \"Pedestal\"\n  [\"preco\"]=>\n  float(75)\n}\n*/</code>",

        "Exemplo 14: Objects - Removendo pedestal e adicionando violão ao final de typedSequence",
        "<code>$iterator = $typedSequence->getIterator();\n$iterator->next();\n$produtoARemover = $iterator->current();\n$typedSequence->remove($produtoARemover);\n$typedSequence->add(Produto::novoProduto()->comNomePreco('Violão', 600));\n\nforeach ($typedSequence as $key => $value) {\n    echo \"$key => <br>\";\n    var_dump($value);\n}\n/*\n0 =>\n\nobject(Produto)#13 (2) {\n  [\"nome\"]=>\n  string(9) \"Microfone\"\n  [\"preco\"]=>\n  float(400)\n}\n\n1 =>\n\nobject(Produto)#3 (2) {\n  [\"nome\"]=>\n  string(7) \"Violão\"\n  [\"preco\"]=>\n  float(600)\n}\n\n*/\n\n$typedSequence->add(['nome'=>'Cordas de violão', 'valor'=>30]);\n/*\nFatal error: Uncaught TypeError: Only values of type Produto are supported in\nC:\\Users\\ruigx\\Desktop\\REPOS\\ruihloliveira.github.io\\teste.php:293 Stack trace:\n#0 C:\\Users\\ruigx\\Desktop\\REPOS\\ruihloliveira.github.io\\teste.php(322): TypedSequence->add()\n#1 {main} thrown in C:\\Users\\ruigx\\Desktop\\REPOS\\ruihloliveira.github.io\\teste.php on line 293\n*/</code>",

        "Exemplo 15: Objects - Implementação de TypedSequence imutável - experimentos com passagem em funções.",
        "<code>/*\nCrio uma função para demonstrar que objetos modificados dentro de funções são os mesmos objetos\nexistentes fora da função (ou seja, passagem por referência por padrão);\n*/\n\nfunction produtoPromocao (Produto $produto, float $porcentagemDesconto) : Produto{\n    $desconto = ( $produto->preco / 100 ) * $porcentagemDesconto;\n    $produto->preco = $produto->preco - $desconto;\n    return $produto;\n}\n$smartphone = Produto::novoProduto()->comNomePreco('Smartphone', 1000);\necho \"antes: <pre>\". var_export($smartphone,true). \"</pre>\";\n\n/*\nantes:\nProduto::__set_state(array(\n   'nome' => 'Smartphone',\n   'preco' => 1000.0,\n))\n*/\n\n$smartphoneComDesconto = produtoPromocao($smartphone, 25);\necho \"depois: <pre>\". var_export($smartphone,true). \"</pre>\";\necho \"com desconto: <pre>\". var_export($smartphoneComDesconto,true). \"</pre>\";\n\n//mudou o valor, passagem por referencia\n/*\ndepois:\nProduto::__set_state(array(\n   'nome' => 'Smartphone',\n   'preco' => 750.0,\n))\n\ncom desconto:\nProduto::__set_state(array(\n   'nome' => 'Smartphone',\n   'preco' => 750.0,\n))\n*/\n\n//usando a função clone no produto ao passar para a função:\n\n\n$smartphoneComDesconto = produtoPromocao(clone($smartphone), 25);\necho \"depois, tendo passado objeto clonado: <pre>\". var_export($smartphone,true). \"</pre>\";\necho \"com desconto, tendo passado objeto clonado: <pre>\". var_export($smartphoneComDesconto,true). \"</pre>\";\n\n//não altera o valor do objeto fora da função\n\n/*\ndepois, tendo passado objeto clonado:\nProduto::__set_state(array(\n   'nome' => 'Smartphone',\n   'preco' => 750.0,\n))\n\ncom desconto, tendo passado objeto clonado:\nProduto::__set_state(array(\n   'nome' => 'Smartphone',\n   'preco' => 562.5,\n))\n*/</code>",

        "<code>//definição da classe Immutable:\n\nclass ImmutableTypedSequence implements \\IteratorAggregate, \\Countable\n{\n    public static function forType(string $type) : iterable {\n        $immutableTypedSequence = new static();\n        $immutableTypedSequence->type = $type;\n        return $immutableTypedSequence;\n    }\n    protected string $type;\n    protected array $values = [];\n    protected function __construct(){}\n\n    public function count() : int {\n        return count($this->values);\n    }\n\n    public function getIterator() : ArrayIterator {\n        return new ArrayIterator($this->values);\n    }\n\n    public function add($newValue): iterable {\n        if(!$newValue instanceof $this->type) {\n            throw new \\TypeError(\n                sprintf('Only values of type %s are supported', $this->type)\n            );\n        }\n        $new = clone($this);\n        $values = [...$this->values, $newValue];\n        $new->values = $values;\n        return $new;\n    }\n\n    public function remove ($value): iterable {\n        if($key = array_search($value, $this->values,true)) {\n            $values = $this->values;\n            unset($values[$key]);\n            $new = clone(this);\n            $new->values = array_values($values);\n            return $new;\n        }\n        return $this;\n    }\n}\n\n$produtoImmutableTypedSequence = ImmutableTypedSequence::forType(Produto::class);\n$produtoImmutableTypedSequence->add(Produto::novoProduto()->comNomePreco('Smartphone',1000));\n\n//adicionou o produto, retornando um novo immutable\n//porém não peguei o novo immutable no retorno\n//o for abaixo não exibe nada\n\nforeach ($produtoImmutableTypedSequence as $key => $value) {\n    echo \"$key => $value\";\n}\n\n\n$produtoImmutableTypedSequence = $produtoImmutableTypedSequence\n    ->add(Produto::novoProduto()->comNomePreco('Caixa de som', 400));\n\n//adicionou o produto, e agora, eu fiz uso do retorno\n//(novo objeto immutable)\n\nforeach ($produtoImmutableTypedSequence as $key => $value) {\n    echo \"$key => <pre>\". var_export($value,true). \"</pre>\";\n}\n\n/*\n0 =>\n\nProduto::__set_state(array(\n   'nome' => 'Caixa de som portatil',\n   'preco' => 400.0,\n))\n*/\n\n//função que duplica elementos de uma sequencia imutável\nfunction duplicaElementos (ImmutableTypedSequence $sequence) : iterable {\n    $newSequence = null;\n    foreach ($sequence as $key => $value) {\n        $newSequence = $sequence->add($value);\n    }\n    return $newSequence;\n}\n\n\necho \"produtoImmutableTypedSequence antes da funcao: <pre> \"\n    . var_export($produtoImmutableTypedSequence,true) . \"</pre>\";\n\nduplicaElementos($produtoImmutableTypedSequence);\necho \"produtoImmutableTypedSequence depois da funcao, inalterado: <pre>\"\n    . var_export($produtoImmutableTypedSequence,true) . \"</pre>\";\n//não altera, pois qualquer alteração na sequencia imutável cria uma nova, mas não altera a original\n//impedindo modificação do objeto fora da função/método\n\n$produtoImmutableTypedSequence = duplicaElementos($produtoImmutableTypedSequence);\necho \"produtoImmutableTypedSequence depois da funcao, substituido pelo retorno da função (alterado): <pre>\"\n    . var_export($produtoImmutableTypedSequence,true) . \"</pre>\";\n\n/*\nprodutoImmutableTypedSequence antes da funcao:\n\n ImmutableTypedSequence::__set_state(array(\n   'type' => 'Produto',\n   'values' => \n  array (\n    0 => \n    Produto::__set_state(array(\n       'nome' => 'Caixa de som',\n       'preco' => 400.0,\n    )),\n  ),\n))\n\nprodutoImmutableTypedSequence depois da funcao, inalterado:\n\nImmutableTypedSequence::__set_state(array(\n   'type' => 'Produto',\n   'values' => \n  array (\n    0 => \n    Produto::__set_state(array(\n       'nome' => 'Caixa de som',\n       'preco' => 400.0,\n    )),\n  ),\n))\n\nprodutoImmutableTypedSequence depois da funcao, substituido pelo retorno da função (alterado):\n\nImmutableTypedSequence::__set_state(array(\n   'type' => 'Produto',\n   'values' => \n  array (\n    0 => \n    Produto::__set_state(array(\n       'nome' => 'Caixa de som',\n       'preco' => 400.0,\n    )),\n    1 => \n    Produto::__set_state(array(\n       'nome' => 'Caixa de som',\n       'preco' => 400.0,\n    )),\n  ),\n))\n*/</code>",

        "Quais são os ganhos com essas estruturas?",
        "Estas estruturas sequenciadas promovem maior segurança de que não existirão erros no tempo de execução do programa relacionado a acessar posições inexistentes do array.",
        "Estruturas tipadas promovem maior segurança, já que não correremos risco de executar métodos ou acessar propriedades de variáveis de tipos que não as possuam.",
        "Estruturas imutáveis impedem comportamento padrão de objetos, que é alteração do objeto original provocada pela passagem de parâmetro por referência. Objetos no PHP são passados por referência (não é exatamente referência, mas é).",
        "Estruturas promovem um código autodocumentado já que objetos são autodocumentados, e passar objetos de configuração por exemplo é melhor que passar arrays de configuração, já que arrays não são autodocumentados.",
        "A documentação é algo que, a não ser em locais onde a cultura de documentação seja seguida de forma estrita, rigorosa, a documentação ficará sempre um pouco desatualizada em relação ao código. Essa é a necessidade do código autodocumentado.",
        "Nossas estruturas também podem ser extendidas (herança) ou compor (composição) classes de domínio com lógicas e métodos que enriqueçam esta classe de domínio. Por exemplo, podemos ter uma lista de produtos que possui um método getTotal, e pode compor um carrinho de compras.",
        "O autor demonstra também o uso de generators para a reimplementação de funções de array mais comuns no nosso dia a dia.",
        "Generator é um recurso do PHP onde uma função pode ser usada como um iterable, com custo reduzido de memória, dado que não utiliza espaço para guardar valores. Os exemplos a seguir mostram de forma mais prática:",
        "Generators - iterable map sem generators e com generators",

        "<code>// funcao sem generators\nfunction iterable_map(iterable $list, callable $operation) : iterable {\n    $arrayResultado = [];\n    foreach ($list as $k => $v) {\n        $arrayResultado[] = $operation($k, $v);\n    }\n    return $arrayResultado;\n}\n\necho \"produtos originais:<br>\";\nforeach ($typedSequence as $k => $v){\n    echo \"$k =><pre>\" . var_export($v,true) . \"</pre>\";\n}\n/*\n0 =>\nProduto::__set_state(array(\n   'nome' => 'Microfone',\n   'preco' => 400.0,\n))\n1 =>\nProduto::__set_state(array(\n   'nome' => 'Violão',\n   'preco' => 600.0,\n))\n*/\n\n//duplicando valor dos produtos sem generator\n$novoIterable = iterable_map($typedSequence, function ($key, $value) {\n    $value->preco = $value->preco * 2;\n    return $value;\n});\n\necho \"Produtos com valores duplicados:<br>\";\nforeach ($novoIterable as $k => $v){\n    echo \"$k =><pre>\" . var_export($v,true) . \"</pre>\";\n}\n/*\n0 =>\nProduto::__set_state(array(\n   'nome' => 'Microfone',\n   'preco' => 800.0,\n))\n1 =>\nProduto::__set_state(array(\n   'nome' => 'Violão',\n   'preco' => 1200.0,\n))\n*/\n\necho \"produtos originais (foram alterados, já que não são immutable):<br>\";\nforeach ($typedSequence as $k => $v){\n    echo \"$k =><pre>\" . var_export($v,true) . \"</pre>\";\n}\n/*\n0 =>\nProduto::__set_state(array(\n   'nome' => 'Microfone',\n   'preco' => 800.0,\n))\n1 =>\nProduto::__set_state(array(\n   'nome' => 'Violão',\n   'preco' => 1200.0,\n))\n*/\n\n//funcao com generators\nfunction iterable_map_generator(iterable $list, callable $operation) : iterable {\n    foreach ($list as $k => $v) {\n        yield $operation($k, $v);\n    }\n}\n\necho \"produtos originais:<br>\";\nforeach ($typedSequence as $k => $v){\n    echo \"$k =><pre>\" . var_export($v,true) . \"</pre>\";\n}\n\n//duplicando valor dos produtos com generators\n$novoIterable = iterable_map_generator($typedSequence, function ($key, $value) {\n    $value->preco = $value->preco * 2;\n    return $value;\n});\n\n//Objetos Generators são iterators, mas não ocupam tanta memória,\n//somente as instruções para geração dos valores\necho \"Objeto Generator<pre>\". var_export($novoIterable,true) . \"</pre>\";\n/*\nGenerator::__set_state(array(\n))\n*/\n\necho \"Produtos com valores duplicados:<br>\";\nforeach ($novoIterable as $k => $v){\n    echo \"$k =><pre>\" . var_export($v,true) . \"</pre>\";\n}\n/*\n0 =>\nProduto::__set_state(array(\n   'nome' => 'Microfone',\n   'preco' => 1600.0,\n))\n1 =>\nProduto::__set_state(array(\n   'nome' => 'Violão',\n   'preco' => 2400.0,\n))\n*/</code>",

        "Outros detalhes apresentados pelo autor:",
        "Propriedades privadas não são necessariamente uma regra. Elas se mostram úteis de fato quando seu objeto faz parte de uma api pública e precisa de tal segurança. Objetos de uso privado da aplicação não precisam ter propriedades privadas. Getters e Setters não são métodos do domínio da aplicação. Eu pessoalmente penso que, uma vez que encaramos uma classe sem getters/setters, incentiva a pensar: o que posso implementar de útil nessa classe? O que esse objeto do meu domínio deve saber fazer além de simplesmente guardar informação?",
        "De acordo com Benchmarks rodados pelo autor original do conteúdo (sempre em comparação com arrays):",
        "Objetos stdClass utilizam 9% mais memória e são 19% mais lentos em processamento;",
        "Todos os objetos não stdClass utilizam 53% menos memória (todos abaixo);",
        "Objetos não stdClass com propriedades públicas são 13% mais rápidos em processamento.",
        "Objetos não stdClass com propriedades privadas são 17,5% mais lentos em processamento;",
        "Classes anônimas são 14% mais rápidas em processamento.",
        "Onde não existem problemas em utilizar arrays? Detalhes internos de implementação, por exemplo, e locais onde a sintaxe te pede para tal.",
        "Estratégia de alto nível para migração de arrays para objetos:",
        "Passo 1 - Em locais onde se trabalha com arrays, mudar a implementação interna de métodos para converter arrays para objetos e trabalhar utilizando esses objetos. O método para tal conversão deve ser implementado na própria classe do objeto criado, ou seja, um construtor que aceita array, ou um método-fábrica estático.",
        "Passo 2 - Disparar avisos e_deprecated, informando ao programador que deve-se utilizar um objeto, passando os detalhes necessários para o programador.",
        "Passo 3 - Remover a opção de uso destes métodos/apis passando arrays, mantendo somente única opção para objetos.",
        "Documentação e autodocumentação de código: Sempre documentar o tipo de um parâmetro, retorno e propriedade. Em casos onde for necessária a tipagem mais específica do que é suportada pela linguagem em si, pode-se usar docblocks, comentários para documentação.",
        "Usar arrays te levam a certos estilos de arquitetura que normalmente não são tão legais, diferente dos objetos, que estimulam, obviamente, uma arquitetura orientada a objetos."
    ]
}